knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(boot)
set.seed(123)  # You can replace 123 with any integer value you like
#STEP 1
# Set the number of data points to 100 (THIS IS THE THING WE HAVE TO CHANGE to 50 , 100, 200, 400, 800, 1600)
Ndata <- 100
# Create a dummy variable Delta1 with 60% chance of being 1 and 40% chance of being 0
Delta1 <- ifelse(runif(Ndata) < 0.6, 1, 0)
#Create X2 based on the value of Delta
X2 <- ifelse(Delta1 == 1, rchisq(Ndata, df = 4), rchisq(Ndata, df = 2))
#Set the true parameters
beta <- c(-1, -1, 1/2)
# Calculate the mean parameter lambda for the Poisson distribution (The Function)
lambda <- exp(beta[1] + beta[2]*Delta1 + beta[3]*X2)
# Define a function to generate random Poisson-distributed numbers (Generate poisson values based of lambda)
generateY <- function(lambda.i) rpois(1, lambda = lambda.i)
# Generate the dependent variable y based on lambda values (Create y vector)
y <- sapply(lambda, generateY)
# Create a data frame with simulated data (store y and the 2 predictors (Delta1 and X2))
data.Pois <- data.frame(
"y" = y,  # Y
"Delta1" = ifelse(Delta1 == 1, TRUE, FALSE),  # Delta 1
"X2" = X2 # X2
)
# Display the first few rows of the data frame
data.Pois
#Use GLM function (STEP 2)
glm.output <- glm( y ~ Delta1 + X2, data=data.Pois, family="poisson")
summary( glm.output )
#Extract betas from the model
beta.hat <- coef(glm.output)
beta.hat
intercept_matrix <- matrix(NA, nrow = 1, ncol = 2)
delta1_matrix <- matrix(NA, nrow = 1, ncol = 2)
x2_matrix <- matrix(NA, nrow = 1, ncol = 2)
#Get the CI for the betas
#Get the Confidence interval for the parameters(95%)
delta95 <- confint(glm.output)
intercept_matrix[1,] <- delta95[1,]
delta1_matrix[1,] <- delta95[2,]
x2_matrix[1,] <- delta95[3,]
#Get the Confidence Interval for the parameters (90%)
delta90 <- confint(glm.output, level = 0.90)
#Get the Confidence Interval forthe parameters (80%)
delta80 <- confint(glm.output, level = 0.80)
#Get the variance-covariance matrix (will be used later)
Sigma.hat.divN <- vcov(glm.output)
Sigma.hat.divN
#We have the coefficients from the GLM and their CIs
#We have CI before transformation and before bootstrap
#Create the  transformation that measures the idea that the Poisson variable is less than 2 (so equal to 0 or 1)
#Use the numerical derivative function from class
numerical.derivative <- function(fun, x) {
nn <- length(x)  # Set nn as the length of input vector x
dx <- rep(NaN, nn)  # Initialize the derivative vector
for (i in 1:nn) {
eps <- rep(0, nn)  # Set epsilon as a zero vector (0,0,..,0)
eps[i] <- 1e-6  # Put a small shift on coordinate i
# Now calculate the derivative using centered difference method
dx[i] <- (fun(x + eps) - fun(x - eps)) / (2e-6)
}
return(dx)  # Return the numerical derivative vector
}
#Create a function that return the probability of Poisson variable being 0 or 1 with Delta1 being 1 and X2 being 4
prob.pois<- function(beta) {
lambda <- exp(beta[1] + beta[2]*1 + beta[3]*4)
p_0 <- dpois(0, lambda)
p_1 <- dpois(1, lambda)
p <- p_0 + p_1
return(p)
}
#Probability if being 0 or 1 separate (ask prof)
#prob.pois.0 <-  function( beta ) dpois(0,lambda=exp(beta[1] + beta[2]*1 + beta[3]*4) )
#prob.pois.1 <-  function( beta ) dpois(1,lambda=exp(beta[1] + beta[2]*1 + beta[3]*4) )
#Get the derivative for the points in the probability based on the beta hat points (for the DELTA METHOD)
dG <- numerical.derivative(prob.pois,beta.hat) # use our vector numerical diff function on it
dG
#Get the estimated Omega
Omega.hat <- t(dG)%*% Sigma.hat.divN %*% dG
Omega.hat
#Check the probability of poisson lower than 2 based on the conditions
prob.pois(beta)
#Check the probability of poisson lower than 2 based on the conditions
prob.pois(beta.hat)
#Square root of Omega Hat (For the Delta Method right below)
sqrt(Omega.hat)
# #Implement the Delta Method (only 95% CI)
# delta.method.out<- c("estimate of zero or 1"=prob.pois(beta.hat),
#                       "std.err"= sqrt(Omega.hat),
#                       "lower.conf"= prob.pois(beta.hat)-1.96*sqrt(Omega.hat),
#                       "upper.conf"= prob.pois(beta.hat)+1.96*sqrt(Omega.hat) )
# delta.method.out
# Implement the Delta Method for 95% confidence interval
lower_95 <- prob.pois(beta.hat) - 1.96 * sqrt(Omega.hat)
upper_95 <- prob.pois(beta.hat) + 1.96 * sqrt(Omega.hat)
# Implement the Delta Method for 90% confidence interval
lower_90 <- prob.pois(beta.hat) - 1.65 * sqrt(Omega.hat)
upper_90 <- prob.pois(beta.hat) + 1.65 * sqrt(Omega.hat)
# Implement the Delta Method for 80% confidence interval
lower_80 <- prob.pois(beta.hat) - 1.28 * sqrt(Omega.hat)
upper_80 <- prob.pois(beta.hat) + 1.28 * sqrt(Omega.hat)
# Store the results
delta.method.out <- c("estimate of 0 or 1" = prob.pois(beta.hat),
"std.err"= sqrt(Omega.hat),
"lower.conf95"=lower_95, # I set names FALSE here to stop quantile names being                                                                                        appended
"upper.conf95"=upper_95,
"lower.conf90"=lower_90, # I set names FALSE here to stop quantile names being                                                                                        appended
"upper.conf90"=upper_90,
"lower.conf80"=lower_80, # I set names FALSE here to stop quantile names being                                                                                        appended
"upper.conf80"=upper_80)
delta.method.out
# Store the results in a dataframe
probdelta <- data.frame(
Estimate = prob.pois(beta.hat),
Std_Err = sqrt(Omega.hat),
Lower_Conf_95 = lower_95,
Upper_Conf_95 = upper_95,
Lower_Conf_90 = lower_90,
Upper_Conf_90 = upper_90,
Lower_Conf_80 = lower_80,
Upper_Conf_80 = upper_80
)
#We create simulations to test our results
#install.packages('MASS')
library(MASS) # we need this to get the multivariate random normal distribution
beta.draws <- replicate(5e5, # replicate things 50000 times
prob.pois( #Figure out the Prob under a Poisson of a zero OR 1 outcome
mvrnorm(1,mu=beta.hat,Sigma=Sigma.hat.divN) # Draw a value of beta hat from the asymptotic distribution
)
)
#get the results of the simulatoin (mean standard error and CIS)
simulation.out <-c("estimate of zero"=mean(beta.draws),
"std.err"= sd(beta.draws),
"lower.conf95"=quantile(beta.draws,0.025,names=FALSE), # I set names FALSE here to stop quantile names being                                                                                        appended
"upper.conf95"=quantile(beta.draws,0.975,names=FALSE),
"lower.conf90"=quantile(beta.draws,0.05,names=FALSE), # I set names FALSE here to stop quantile names being                                                                                        appended
"upper.conf90"=quantile(beta.draws,0.95,names=FALSE),
"lower.conf80"=quantile(beta.draws,0.1,names=FALSE), # I set names FALSE here to stop quantile names being                                                                                        appended
"upper.conf80"=quantile(beta.draws,0.9,names=FALSE))
simulation.out
# Store the results in a dataframe
probsim <- data.frame(
Estimate = mean(beta.draws),
Std_Err = sd(beta.draws),
Lower_Conf_95 = quantile(beta.draws, 0.025, names = FALSE),
Upper_Conf_95 = quantile(beta.draws, 0.975, names = FALSE),
Lower_Conf_90 = quantile(beta.draws, 0.05, names = FALSE),
Upper_Conf_90 = quantile(beta.draws, 0.95, names = FALSE),
Lower_Conf_80 = quantile(beta.draws, 0.1, names = FALSE),
Upper_Conf_80 = quantile(beta.draws, 0.9, names = FALSE)
)
